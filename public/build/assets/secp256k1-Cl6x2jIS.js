import{O as Ft,R as Bt,S as bt,T as Wt,U as Ht,V as xe,W as yt,X as Be,Y as K,Z as Pt,$ as st,a0 as Ut,a1 as mt,a2 as W,a3 as ve,a4 as Qt}from"./app-B3S15xZN.js";function Se(n,t,r,e){if(typeof n.setBigUint64=="function")return n.setBigUint64(t,r,e);const o=BigInt(32),i=BigInt(4294967295),s=Number(r>>o&i),c=Number(r&i),f=e?4:0,w=e?0:4;n.setUint32(t+f,s,e),n.setUint32(t+w,c,e)}function Ie(n,t,r){return n&t^~n&r}function Ae(n,t,r){return n&t^n&r^t&r}class _e extends Ft{constructor(t,r,e,o){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=t,this.outputLen=r,this.padOffset=e,this.isLE=o,this.buffer=new Uint8Array(t),this.view=Bt(this.buffer)}update(t){bt(this),t=Wt(t),Ht(t);const{view:r,buffer:e,blockLen:o}=this,i=t.length;for(let s=0;s<i;){const c=Math.min(o-this.pos,i-s);if(c===o){const f=Bt(t);for(;o<=i-s;s+=o)this.process(f,s);continue}e.set(t.subarray(s,s+c),this.pos),this.pos+=c,s+=c,this.pos===o&&(this.process(r,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){bt(this),xe(t,this),this.finished=!0;const{buffer:r,view:e,blockLen:o,isLE:i}=this;let{pos:s}=this;r[s++]=128,yt(this.buffer.subarray(s)),this.padOffset>o-s&&(this.process(e,0),s=0);for(let b=s;b<o;b++)r[b]=0;Se(e,o-8,BigInt(this.length*8),i),this.process(e,0);const c=Bt(t),f=this.outputLen;if(f%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const w=f/4,y=this.get();if(w>y.length)throw new Error("_sha2: outputLen bigger than state");for(let b=0;b<w;b++)c.setUint32(4*b,y[b],i)}digest(){const{buffer:t,outputLen:r}=this;this.digestInto(t);const e=t.slice(0,r);return this.destroy(),e}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:r,buffer:e,length:o,finished:i,destroyed:s,pos:c}=this;return t.destroyed=s,t.finished=i,t.length=o,t.pos=c,o%r&&t.buffer.set(e),t}clone(){return this._cloneInto()}}const G=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),Ne=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),F=new Uint32Array(64);class qe extends _e{constructor(t=32){super(64,t,8,!1),this.A=G[0]|0,this.B=G[1]|0,this.C=G[2]|0,this.D=G[3]|0,this.E=G[4]|0,this.F=G[5]|0,this.G=G[6]|0,this.H=G[7]|0}get(){const{A:t,B:r,C:e,D:o,E:i,F:s,G:c,H:f}=this;return[t,r,e,o,i,s,c,f]}set(t,r,e,o,i,s,c,f){this.A=t|0,this.B=r|0,this.C=e|0,this.D=o|0,this.E=i|0,this.F=s|0,this.G=c|0,this.H=f|0}process(t,r){for(let b=0;b<16;b++,r+=4)F[b]=t.getUint32(r,!1);for(let b=16;b<64;b++){const a=F[b-15],d=F[b-2],p=K(a,7)^K(a,18)^a>>>3,B=K(d,17)^K(d,19)^d>>>10;F[b]=B+F[b-7]+p+F[b-16]|0}let{A:e,B:o,C:i,D:s,E:c,F:f,G:w,H:y}=this;for(let b=0;b<64;b++){const a=K(c,6)^K(c,11)^K(c,25),d=y+a+Ie(c,f,w)+Ne[b]+F[b]|0,B=(K(e,2)^K(e,13)^K(e,22))+Ae(e,o,i)|0;y=w,w=f,f=c,c=s+d|0,s=i,i=o,o=e,e=d+B|0}e=e+this.A|0,o=o+this.B|0,i=i+this.C|0,s=s+this.D|0,c=c+this.E|0,f=f+this.F|0,w=w+this.G|0,y=y+this.H|0,this.set(e,o,i,s,c,f,w,y)}roundClean(){yt(F)}destroy(){this.set(0,0,0,0,0,0,0,0),yt(this.buffer)}}const Oe=Be(()=>new qe);class Jt extends Ft{constructor(t,r){super(),this.finished=!1,this.destroyed=!1,Pt(t);const e=Wt(r);if(this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,i=new Uint8Array(o);i.set(e.length>o?t.create().update(e).digest():e);for(let s=0;s<i.length;s++)i[s]^=54;this.iHash.update(i),this.oHash=t.create();for(let s=0;s<i.length;s++)i[s]^=106;this.oHash.update(i),yt(i)}update(t){return bt(this),this.iHash.update(t),this}digestInto(t){bt(this),Ht(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:r,iHash:e,finished:o,destroyed:i,blockLen:s,outputLen:c}=this;return t=t,t.finished=o,t.destroyed=i,t.blockLen=s,t.outputLen=c,t.oHash=r._cloneInto(t.oHash),t.iHash=e._cloneInto(t.iHash),t}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const te=(n,t,r)=>new Jt(n,t).update(r).digest();te.create=(n,t)=>new Jt(n,t);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Zt=BigInt(0),qt=BigInt(1);function pt(n,t=""){if(typeof n!="boolean"){const r=t&&`"${t}"`;throw new Error(r+"expected boolean, got type="+typeof n)}return n}function J(n,t,r=""){const e=Ut(n),o=n==null?void 0:n.length,i=t!==void 0;if(!e||i&&o!==t){const s=r&&`"${r}" `,c=i?` of length ${t}`:"",f=e?`length=${o}`:`type=${typeof n}`;throw new Error(s+"expected Uint8Array"+c+", got "+f)}return n}function wt(n){const t=n.toString(16);return t.length&1?"0"+t:t}function ee(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);return n===""?Zt:BigInt("0x"+n)}function xt(n){return ee(st(n))}function ne(n){return Ht(n),ee(st(Uint8Array.from(n).reverse()))}function Lt(n,t){return mt(n.toString(16).padStart(t*2,"0"))}function re(n,t){return Lt(n,t).reverse()}function M(n,t,r){let e;if(typeof t=="string")try{e=mt(t)}catch(o){throw new Error(n+" must be hex string or Uint8Array, cause: "+o)}else if(Ut(t))e=Uint8Array.from(t);else throw new Error(n+" must be hex string or Uint8Array");return e.length,e}const vt=n=>typeof n=="bigint"&&Zt<=n;function Re(n,t,r){return vt(n)&&vt(t)&&vt(r)&&t<=n&&n<r}function He(n,t,r,e){if(!Re(t,r,e))throw new Error("expected valid "+n+": "+r+" <= n < "+e+", got "+t)}function oe(n){let t;for(t=0;n>Zt;n>>=qt,t+=1);return t}const at=n=>(qt<<BigInt(n))-qt;function Ue(n,t,r){if(typeof n!="number"||n<2)throw new Error("hashLen must be a number");if(typeof t!="number"||t<2)throw new Error("qByteLen must be a number");if(typeof r!="function")throw new Error("hmacFn must be a function");const e=d=>new Uint8Array(d),o=d=>Uint8Array.of(d);let i=e(n),s=e(n),c=0;const f=()=>{i.fill(1),s.fill(0),c=0},w=(...d)=>r(s,i,...d),y=(d=e(0))=>{s=w(o(0),d),i=w(),d.length!==0&&(s=w(o(1),d),i=w())},b=()=>{if(c++>=1e3)throw new Error("drbg: tried 1000 values");let d=0;const p=[];for(;d<t;){i=w();const B=i.slice();p.push(B),d+=i.length}return W(...p)};return(d,p)=>{f(),y(d);let B;for(;!(B=p(b()));)y();return f(),B}}function Vt(n,t,r={}){if(!n||typeof n!="object")throw new Error("expected valid options object");function e(o,i,s){const c=n[o];if(s&&c===void 0)return;const f=typeof c;if(f!==i||c===null)throw new Error(`param "${o}" is invalid: expected ${i}, got ${f}`)}Object.entries(t).forEach(([o,i])=>e(o,i,!1)),Object.entries(r).forEach(([o,i])=>e(o,i,!0))}function $t(n){const t=new WeakMap;return(r,...e)=>{const o=t.get(r);if(o!==void 0)return o;const i=n(r,...e);return t.set(r,i),i}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const $=BigInt(0),k=BigInt(1),tt=BigInt(2),se=BigInt(3),ie=BigInt(4),ce=BigInt(5),Ze=BigInt(7),fe=BigInt(8),Le=BigInt(9),ae=BigInt(16);function Y(n,t){const r=n%t;return r>=$?r:t+r}function j(n,t,r){let e=n;for(;t-- >$;)e*=e,e%=r;return e}function jt(n,t){if(n===$)throw new Error("invert: expected non-zero number");if(t<=$)throw new Error("invert: expected positive modulus, got "+t);let r=Y(n,t),e=t,o=$,i=k;for(;r!==$;){const c=e/r,f=e%r,w=o-i*c;e=r,r=f,o=i,i=w}if(e!==k)throw new Error("invert: does not exist");return Y(o,t)}function Tt(n,t,r){if(!n.eql(n.sqr(t),r))throw new Error("Cannot find square root")}function ue(n,t){const r=(n.ORDER+k)/ie,e=n.pow(t,r);return Tt(n,e,t),e}function Ve(n,t){const r=(n.ORDER-ce)/fe,e=n.mul(t,tt),o=n.pow(e,r),i=n.mul(t,o),s=n.mul(n.mul(i,tt),o),c=n.mul(i,n.sub(s,n.ONE));return Tt(n,c,t),c}function Te(n){const t=ut(n),r=le(n),e=r(t,t.neg(t.ONE)),o=r(t,e),i=r(t,t.neg(e)),s=(n+Ze)/ae;return(c,f)=>{let w=c.pow(f,s),y=c.mul(w,e);const b=c.mul(w,o),a=c.mul(w,i),d=c.eql(c.sqr(y),f),p=c.eql(c.sqr(b),f);w=c.cmov(w,y,d),y=c.cmov(a,b,p);const B=c.eql(c.sqr(y),f),q=c.cmov(w,y,B);return Tt(c,q,f),q}}function le(n){if(n<se)throw new Error("sqrt is not defined for small field");let t=n-k,r=0;for(;t%tt===$;)t/=tt,r++;let e=tt;const o=ut(n);for(;Yt(o,e)===1;)if(e++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(r===1)return ue;let i=o.pow(e,t);const s=(t+k)/tt;return function(f,w){if(f.is0(w))return w;if(Yt(f,w)!==1)throw new Error("Cannot find square root");let y=r,b=f.mul(f.ONE,i),a=f.pow(w,t),d=f.pow(w,s);for(;!f.eql(a,f.ONE);){if(f.is0(a))return f.ZERO;let p=1,B=f.sqr(a);for(;!f.eql(B,f.ONE);)if(p++,B=f.sqr(B),p===y)throw new Error("Cannot find square root");const q=k<<BigInt(y-p-1),U=f.pow(b,q);y=p,b=f.sqr(U),a=f.mul(a,b),d=f.mul(d,U)}return d}}function ke(n){return n%ie===se?ue:n%fe===ce?Ve:n%ae===Le?Te(n):le(n)}const Ce=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Me(n){const t={ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"},r=Ce.reduce((e,o)=>(e[o]="function",e),t);return Vt(n,r),n}function $e(n,t,r){if(r<$)throw new Error("invalid exponent, negatives unsupported");if(r===$)return n.ONE;if(r===k)return t;let e=n.ONE,o=t;for(;r>$;)r&k&&(e=n.mul(e,o)),o=n.sqr(o),r>>=k;return e}function de(n,t,r=!1){const e=new Array(t.length).fill(r?n.ZERO:void 0),o=t.reduce((s,c,f)=>n.is0(c)?s:(e[f]=s,n.mul(s,c)),n.ONE),i=n.inv(o);return t.reduceRight((s,c,f)=>n.is0(c)?s:(e[f]=n.mul(s,e[f]),n.mul(s,c)),i),e}function Yt(n,t){const r=(n.ORDER-k)/tt,e=n.pow(t,r),o=n.eql(e,n.ONE),i=n.eql(e,n.ZERO),s=n.eql(e,n.neg(n.ONE));if(!o&&!i&&!s)throw new Error("invalid Legendre symbol result");return o?1:i?0:-1}function he(n,t){t!==void 0&&ve(t);const r=t!==void 0?t:n.toString(2).length,e=Math.ceil(r/8);return{nBitLength:r,nByteLength:e}}function ut(n,t,r=!1,e={}){if(n<=$)throw new Error("invalid field: expected ORDER > 0, got "+n);let o,i,s=!1,c;if(typeof t=="object"&&t!=null){if(e.sqrt||r)throw new Error("cannot specify opts in two arguments");const a=t;a.BITS&&(o=a.BITS),a.sqrt&&(i=a.sqrt),typeof a.isLE=="boolean"&&(r=a.isLE),typeof a.modFromBytes=="boolean"&&(s=a.modFromBytes),c=a.allowedLengths}else typeof t=="number"&&(o=t),e.sqrt&&(i=e.sqrt);const{nBitLength:f,nByteLength:w}=he(n,o);if(w>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let y;const b=Object.freeze({ORDER:n,isLE:r,BITS:f,BYTES:w,MASK:at(f),ZERO:$,ONE:k,allowedLengths:c,create:a=>Y(a,n),isValid:a=>{if(typeof a!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof a);return $<=a&&a<n},is0:a=>a===$,isValidNot0:a=>!b.is0(a)&&b.isValid(a),isOdd:a=>(a&k)===k,neg:a=>Y(-a,n),eql:(a,d)=>a===d,sqr:a=>Y(a*a,n),add:(a,d)=>Y(a+d,n),sub:(a,d)=>Y(a-d,n),mul:(a,d)=>Y(a*d,n),pow:(a,d)=>$e(b,a,d),div:(a,d)=>Y(a*jt(d,n),n),sqrN:a=>a*a,addN:(a,d)=>a+d,subN:(a,d)=>a-d,mulN:(a,d)=>a*d,inv:a=>jt(a,n),sqrt:i||(a=>(y||(y=ke(n)),y(b,a))),toBytes:a=>r?re(a,w):Lt(a,w),fromBytes:(a,d=!0)=>{if(c){if(!c.includes(a.length)||a.length>w)throw new Error("Field.fromBytes: expected "+c+" bytes, got "+a.length);const B=new Uint8Array(w);B.set(a,r?0:B.length-a.length),a=B}if(a.length!==w)throw new Error("Field.fromBytes: expected "+w+" bytes, got "+a.length);let p=r?ne(a):xt(a);if(s&&(p=Y(p,n)),!d&&!b.isValid(p))throw new Error("invalid field element: outside of range 0..ORDER");return p},invertBatch:a=>de(b,a),cmov:(a,d,p)=>p?d:a});return Object.freeze(b)}function we(n){if(typeof n!="bigint")throw new Error("field order must be bigint");const t=n.toString(2).length;return Math.ceil(t/8)}function ge(n){const t=we(n);return t+Math.ceil(t/2)}function je(n,t,r=!1){const e=n.length,o=we(t),i=ge(t);if(e<16||e<i||e>1024)throw new Error("expected "+i+"-1024 bytes of input, got "+e);const s=r?ne(n):xt(n),c=Y(s,t-k)+k;return r?re(c,o):Lt(c,o)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const ct=BigInt(0),et=BigInt(1);function Et(n,t){const r=t.negate();return n?r:t}function St(n,t){const r=de(n.Fp,t.map(e=>e.Z));return t.map((e,o)=>n.fromAffine(e.toAffine(r[o])))}function be(n,t){if(!Number.isSafeInteger(n)||n<=0||n>t)throw new Error("invalid window size, expected [1.."+t+"], got W="+n)}function It(n,t){be(n,t);const r=Math.ceil(t/n)+1,e=2**(n-1),o=2**n,i=at(n),s=BigInt(n);return{windows:r,windowSize:e,mask:i,maxNumber:o,shiftBy:s}}function Kt(n,t,r){const{windowSize:e,mask:o,maxNumber:i,shiftBy:s}=r;let c=Number(n&o),f=n>>s;c>e&&(c-=i,f+=et);const w=t*e,y=w+Math.abs(c)-1,b=c===0,a=c<0,d=t%2!==0;return{nextN:f,offset:y,isZero:b,isNeg:a,isNegF:d,offsetF:w}}function Ye(n,t){if(!Array.isArray(n))throw new Error("array expected");n.forEach((r,e)=>{if(!(r instanceof t))throw new Error("invalid point at index "+e)})}function Ke(n,t){if(!Array.isArray(n))throw new Error("array of scalars expected");n.forEach((r,e)=>{if(!t.isValid(r))throw new Error("invalid scalar at index "+e)})}const At=new WeakMap,ye=new WeakMap;function _t(n){return ye.get(n)||1}function zt(n){if(n!==ct)throw new Error("invalid wNAF")}class ze{constructor(t,r){this.BASE=t.BASE,this.ZERO=t.ZERO,this.Fn=t.Fn,this.bits=r}_unsafeLadder(t,r,e=this.ZERO){let o=t;for(;r>ct;)r&et&&(e=e.add(o)),o=o.double(),r>>=et;return e}precomputeWindow(t,r){const{windows:e,windowSize:o}=It(r,this.bits),i=[];let s=t,c=s;for(let f=0;f<e;f++){c=s,i.push(c);for(let w=1;w<o;w++)c=c.add(s),i.push(c);s=c.double()}return i}wNAF(t,r,e){if(!this.Fn.isValid(e))throw new Error("invalid scalar");let o=this.ZERO,i=this.BASE;const s=It(t,this.bits);for(let c=0;c<s.windows;c++){const{nextN:f,offset:w,isZero:y,isNeg:b,isNegF:a,offsetF:d}=Kt(e,c,s);e=f,y?i=i.add(Et(a,r[d])):o=o.add(Et(b,r[w]))}return zt(e),{p:o,f:i}}wNAFUnsafe(t,r,e,o=this.ZERO){const i=It(t,this.bits);for(let s=0;s<i.windows&&e!==ct;s++){const{nextN:c,offset:f,isZero:w,isNeg:y}=Kt(e,s,i);if(e=c,!w){const b=r[f];o=o.add(y?b.negate():b)}}return zt(e),o}getPrecomputes(t,r,e){let o=At.get(r);return o||(o=this.precomputeWindow(r,t),t!==1&&(typeof e=="function"&&(o=e(o)),At.set(r,o))),o}cached(t,r,e){const o=_t(t);return this.wNAF(o,this.getPrecomputes(o,t,e),r)}unsafe(t,r,e,o){const i=_t(t);return i===1?this._unsafeLadder(t,r,o):this.wNAFUnsafe(i,this.getPrecomputes(i,t,e),r,o)}createCache(t,r){be(r,this.bits),ye.set(t,r),At.delete(t)}hasCache(t){return _t(t)!==1}}function De(n,t,r,e){let o=t,i=n.ZERO,s=n.ZERO;for(;r>ct||e>ct;)r&et&&(i=i.add(o)),e&et&&(s=s.add(o)),o=o.double(),r>>=et,e>>=et;return{p1:i,p2:s}}function Xe(n,t,r,e){Ye(r,n),Ke(e,t);const o=r.length,i=e.length;if(o!==i)throw new Error("arrays of points and scalars must have equal length");const s=n.ZERO,c=oe(BigInt(o));let f=1;c>12?f=c-3:c>4?f=c-2:c>0&&(f=2);const w=at(f),y=new Array(Number(w)+1).fill(s),b=Math.floor((t.BITS-1)/f)*f;let a=s;for(let d=b;d>=0;d-=f){y.fill(s);for(let B=0;B<i;B++){const q=e[B],U=Number(q>>BigInt(d)&w);y[U]=y[U].add(r[B])}let p=s;for(let B=y.length-1,q=s;B>0;B--)q=q.add(y[B]),p=p.add(q);if(a=a.add(p),d!==0)for(let B=0;B<f;B++)a=a.double()}return a}function Dt(n,t,r){if(t){if(t.ORDER!==n)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return Me(t),t}else return ut(n,{isLE:r})}function Ge(n,t,r={},e){if(e===void 0&&(e=n==="edwards"),!t||typeof t!="object")throw new Error(`expected valid ${n} CURVE object`);for(const f of["p","n","h"]){const w=t[f];if(!(typeof w=="bigint"&&w>ct))throw new Error(`CURVE.${f} must be positive bigint`)}const o=Dt(t.p,r.Fp,e),i=Dt(t.n,r.Fn,e),c=["Gx","Gy","a","b"];for(const f of c)if(!o.isValid(t[f]))throw new Error(`CURVE.${f} must be valid field element of CURVE.Fp`);return t=Object.freeze(Object.assign({},t)),{CURVE:t,Fp:o,Fn:i}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Xt=(n,t)=>(n+(n>=0?t:-t)/me)/t;function Fe(n,t,r){const[[e,o],[i,s]]=t,c=Xt(s*n,r),f=Xt(-o*n,r);let w=n-c*e-f*i,y=-c*o-f*s;const b=w<D,a=y<D;b&&(w=-w),a&&(y=-y);const d=at(Math.ceil(oe(r)/2))+it;if(w<D||w>=d||y<D||y>=d)throw new Error("splitScalar (endomorphism): failed, k="+n);return{k1neg:b,k1:w,k2neg:a,k2:y}}function Ot(n){if(!["compact","recovered","der"].includes(n))throw new Error('Signature format must be "compact", "recovered", or "der"');return n}function Nt(n,t){const r={};for(let e of Object.keys(t))r[e]=n[e]===void 0?t[e]:n[e];return pt(r.lowS,"lowS"),pt(r.prehash,"prehash"),r.format!==void 0&&Ot(r.format),r}class We extends Error{constructor(t=""){super(t)}}const z={Err:We,_tlv:{encode:(n,t)=>{const{Err:r}=z;if(n<0||n>256)throw new r("tlv.encode: wrong tag");if(t.length&1)throw new r("tlv.encode: unpadded data");const e=t.length/2,o=wt(e);if(o.length/2&128)throw new r("tlv.encode: long form length too big");const i=e>127?wt(o.length/2|128):"";return wt(n)+i+o+t},decode(n,t){const{Err:r}=z;let e=0;if(n<0||n>256)throw new r("tlv.encode: wrong tag");if(t.length<2||t[e++]!==n)throw new r("tlv.decode: wrong tlv");const o=t[e++],i=!!(o&128);let s=0;if(!i)s=o;else{const f=o&127;if(!f)throw new r("tlv.decode(long): indefinite length not supported");if(f>4)throw new r("tlv.decode(long): byte length is too big");const w=t.subarray(e,e+f);if(w.length!==f)throw new r("tlv.decode: length bytes not complete");if(w[0]===0)throw new r("tlv.decode(long): zero leftmost byte");for(const y of w)s=s<<8|y;if(e+=f,s<128)throw new r("tlv.decode(long): not minimal encoding")}const c=t.subarray(e,e+s);if(c.length!==s)throw new r("tlv.decode: wrong value length");return{v:c,l:t.subarray(e+s)}}},_int:{encode(n){const{Err:t}=z;if(n<D)throw new t("integer: negative integers are not allowed");let r=wt(n);if(Number.parseInt(r[0],16)&8&&(r="00"+r),r.length&1)throw new t("unexpected DER parsing assertion: unpadded hex");return r},decode(n){const{Err:t}=z;if(n[0]&128)throw new t("invalid signature integer: negative");if(n[0]===0&&!(n[1]&128))throw new t("invalid signature integer: unnecessary leading zero");return xt(n)}},toSig(n){const{Err:t,_int:r,_tlv:e}=z,o=M("signature",n),{v:i,l:s}=e.decode(48,o);if(s.length)throw new t("invalid signature: left bytes after parsing");const{v:c,l:f}=e.decode(2,i),{v:w,l:y}=e.decode(2,f);if(y.length)throw new t("invalid signature: left bytes after parsing");return{r:r.decode(c),s:r.decode(w)}},hexFromSig(n){const{_tlv:t,_int:r}=z,e=t.encode(2,r.encode(n.r)),o=t.encode(2,r.encode(n.s)),i=e+o;return t.encode(48,i)}},D=BigInt(0),it=BigInt(1),me=BigInt(2),gt=BigInt(3),Pe=BigInt(4);function ot(n,t){const{BYTES:r}=n;let e;if(typeof t=="bigint")e=t;else{let o=M("private key",t);try{e=n.fromBytes(o)}catch{throw new Error(`invalid private key: expected ui8a of size ${r}, got ${typeof t}`)}}if(!n.isValidNot0(e))throw new Error("invalid private key: out of range [1..N-1]");return e}function Qe(n,t={}){const r=Ge("weierstrass",n,t),{Fp:e,Fn:o}=r;let i=r.CURVE;const{h:s,n:c}=i;Vt(t,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});const{endo:f}=t;if(f&&(!e.is0(i.a)||typeof f.beta!="bigint"||!Array.isArray(f.basises)))throw new Error('invalid endo: expected "beta": bigint and "basises": array');const w=Ee(e,o);function y(){if(!e.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function b(N,h,l){const{x:u,y:g}=h.toAffine(),m=e.toBytes(u);if(pt(l,"isCompressed"),l){y();const v=!e.isOdd(g);return W(pe(v),m)}else return W(Uint8Array.of(4),m,e.toBytes(g))}function a(N){J(N,void 0,"Point");const{publicKey:h,publicKeyUncompressed:l}=w,u=N.length,g=N[0],m=N.subarray(1);if(u===h&&(g===2||g===3)){const v=e.fromBytes(m);if(!e.isValid(v))throw new Error("bad point: is not on curve, wrong x");const x=B(v);let E;try{E=e.sqrt(x)}catch(L){const O=L instanceof Error?": "+L.message:"";throw new Error("bad point: is not on curve, sqrt error"+O)}y();const S=e.isOdd(E);return(g&1)===1!==S&&(E=e.neg(E)),{x:v,y:E}}else if(u===l&&g===4){const v=e.BYTES,x=e.fromBytes(m.subarray(0,v)),E=e.fromBytes(m.subarray(v,v*2));if(!q(x,E))throw new Error("bad point: is not on curve");return{x,y:E}}else throw new Error(`bad point: got length ${u}, expected compressed=${h} or uncompressed=${l}`)}const d=t.toBytes||b,p=t.fromBytes||a;function B(N){const h=e.sqr(N),l=e.mul(h,N);return e.add(e.add(l,e.mul(N,i.a)),i.b)}function q(N,h){const l=e.sqr(h),u=B(N);return e.eql(l,u)}if(!q(i.Gx,i.Gy))throw new Error("bad curve params: generator point");const U=e.mul(e.pow(i.a,gt),Pe),ft=e.mul(e.sqr(i.b),BigInt(27));if(e.is0(e.add(U,ft)))throw new Error("bad curve params: a or b");function Z(N,h,l=!1){if(!e.isValid(h)||l&&e.is0(h))throw new Error(`bad point coordinate ${N}`);return h}function P(N){if(!(N instanceof A))throw new Error("ProjectivePoint expected")}function X(N){if(!f||!f.basises)throw new Error("no endo");return Fe(N,f.basises,o.ORDER)}const nt=$t((N,h)=>{const{X:l,Y:u,Z:g}=N;if(e.eql(g,e.ONE))return{x:l,y:u};const m=N.is0();h==null&&(h=m?e.ONE:e.inv(g));const v=e.mul(l,h),x=e.mul(u,h),E=e.mul(g,h);if(m)return{x:e.ZERO,y:e.ZERO};if(!e.eql(E,e.ONE))throw new Error("invZ was invalid");return{x:v,y:x}}),lt=$t(N=>{if(N.is0()){if(t.allowInfinityPoint&&!e.is0(N.Y))return;throw new Error("bad point: ZERO")}const{x:h,y:l}=N.toAffine();if(!e.isValid(h)||!e.isValid(l))throw new Error("bad point: x or y not field elements");if(!q(h,l))throw new Error("bad point: equation left != right");if(!N.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function rt(N,h,l,u,g){return l=new A(e.mul(l.X,N),l.Y,l.Z),h=Et(u,h),l=Et(g,l),h.add(l)}class A{constructor(h,l,u){this.X=Z("x",h),this.Y=Z("y",l,!0),this.Z=Z("z",u),Object.freeze(this)}static CURVE(){return i}static fromAffine(h){const{x:l,y:u}=h||{};if(!h||!e.isValid(l)||!e.isValid(u))throw new Error("invalid affine point");if(h instanceof A)throw new Error("projective point not allowed");return e.is0(l)&&e.is0(u)?A.ZERO:new A(l,u,e.ONE)}static fromBytes(h){const l=A.fromAffine(p(J(h,void 0,"point")));return l.assertValidity(),l}static fromHex(h){return A.fromBytes(M("pointHex",h))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(h=8,l=!0){return Q.createCache(this,h),l||this.multiply(gt),this}assertValidity(){lt(this)}hasEvenY(){const{y:h}=this.toAffine();if(!e.isOdd)throw new Error("Field doesn't support isOdd");return!e.isOdd(h)}equals(h){P(h);const{X:l,Y:u,Z:g}=this,{X:m,Y:v,Z:x}=h,E=e.eql(e.mul(l,x),e.mul(m,g)),S=e.eql(e.mul(u,x),e.mul(v,g));return E&&S}negate(){return new A(this.X,e.neg(this.Y),this.Z)}double(){const{a:h,b:l}=i,u=e.mul(l,gt),{X:g,Y:m,Z:v}=this;let x=e.ZERO,E=e.ZERO,S=e.ZERO,I=e.mul(g,g),L=e.mul(m,m),O=e.mul(v,v),_=e.mul(g,m);return _=e.add(_,_),S=e.mul(g,v),S=e.add(S,S),x=e.mul(h,S),E=e.mul(u,O),E=e.add(x,E),x=e.sub(L,E),E=e.add(L,E),E=e.mul(x,E),x=e.mul(_,x),S=e.mul(u,S),O=e.mul(h,O),_=e.sub(I,O),_=e.mul(h,_),_=e.add(_,S),S=e.add(I,I),I=e.add(S,I),I=e.add(I,O),I=e.mul(I,_),E=e.add(E,I),O=e.mul(m,v),O=e.add(O,O),I=e.mul(O,_),x=e.sub(x,I),S=e.mul(O,L),S=e.add(S,S),S=e.add(S,S),new A(x,E,S)}add(h){P(h);const{X:l,Y:u,Z:g}=this,{X:m,Y:v,Z:x}=h;let E=e.ZERO,S=e.ZERO,I=e.ZERO;const L=i.a,O=e.mul(i.b,gt);let _=e.mul(l,m),R=e.mul(u,v),V=e.mul(g,x),C=e.add(l,u),H=e.add(m,v);C=e.mul(C,H),H=e.add(_,R),C=e.sub(C,H),H=e.add(l,g);let T=e.add(m,x);return H=e.mul(H,T),T=e.add(_,V),H=e.sub(H,T),T=e.add(u,g),E=e.add(v,x),T=e.mul(T,E),E=e.add(R,V),T=e.sub(T,E),I=e.mul(L,H),E=e.mul(O,V),I=e.add(E,I),E=e.sub(R,I),I=e.add(R,I),S=e.mul(E,I),R=e.add(_,_),R=e.add(R,_),V=e.mul(L,V),H=e.mul(O,H),R=e.add(R,V),V=e.sub(_,V),V=e.mul(L,V),H=e.add(H,V),_=e.mul(R,H),S=e.add(S,_),_=e.mul(T,H),E=e.mul(C,E),E=e.sub(E,_),_=e.mul(C,R),I=e.mul(T,I),I=e.add(I,_),new A(E,S,I)}subtract(h){return this.add(h.negate())}is0(){return this.equals(A.ZERO)}multiply(h){const{endo:l}=t;if(!o.isValidNot0(h))throw new Error("invalid scalar: out of range");let u,g;const m=v=>Q.cached(this,v,x=>St(A,x));if(l){const{k1neg:v,k1:x,k2neg:E,k2:S}=X(h),{p:I,f:L}=m(x),{p:O,f:_}=m(S);g=L.add(_),u=rt(l.beta,I,O,v,E)}else{const{p:v,f:x}=m(h);u=v,g=x}return St(A,[u,g])[0]}multiplyUnsafe(h){const{endo:l}=t,u=this;if(!o.isValid(h))throw new Error("invalid scalar: out of range");if(h===D||u.is0())return A.ZERO;if(h===it)return u;if(Q.hasCache(this))return this.multiply(h);if(l){const{k1neg:g,k1:m,k2neg:v,k2:x}=X(h),{p1:E,p2:S}=De(A,u,m,x);return rt(l.beta,E,S,g,v)}else return Q.unsafe(u,h)}multiplyAndAddUnsafe(h,l,u){const g=this.multiplyUnsafe(l).add(h.multiplyUnsafe(u));return g.is0()?void 0:g}toAffine(h){return nt(this,h)}isTorsionFree(){const{isTorsionFree:h}=t;return s===it?!0:h?h(A,this):Q.unsafe(this,c).is0()}clearCofactor(){const{clearCofactor:h}=t;return s===it?this:h?h(A,this):this.multiplyUnsafe(s)}isSmallOrder(){return this.multiplyUnsafe(s).is0()}toBytes(h=!0){return pt(h,"isCompressed"),this.assertValidity(),d(A,this,h)}toHex(h=!0){return st(this.toBytes(h))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get px(){return this.X}get py(){return this.X}get pz(){return this.Z}toRawBytes(h=!0){return this.toBytes(h)}_setWindowSize(h){this.precompute(h)}static normalizeZ(h){return St(A,h)}static msm(h,l){return Xe(A,o,h,l)}static fromPrivateKey(h){return A.BASE.multiply(ot(o,h))}}A.BASE=new A(i.Gx,i.Gy,e.ONE),A.ZERO=new A(e.ZERO,e.ONE,e.ZERO),A.Fp=e,A.Fn=o;const dt=o.BITS,Q=new ze(A,t.endo?Math.ceil(dt/2):dt);return A.BASE.precompute(8),A}function pe(n){return Uint8Array.of(n?2:3)}function Ee(n,t){return{secretKey:t.BYTES,publicKey:1+n.BYTES,publicKeyUncompressed:1+2*n.BYTES,publicKeyHasPrefix:!0,signature:2*t.BYTES}}function Je(n,t={}){const{Fn:r}=n,e=t.randomBytes||Qt,o=Object.assign(Ee(n.Fp,r),{seed:ge(r.ORDER)});function i(d){try{return!!ot(r,d)}catch{return!1}}function s(d,p){const{publicKey:B,publicKeyUncompressed:q}=o;try{const U=d.length;return p===!0&&U!==B||p===!1&&U!==q?!1:!!n.fromBytes(d)}catch{return!1}}function c(d=e(o.seed)){return je(J(d,o.seed,"seed"),r.ORDER)}function f(d,p=!0){return n.BASE.multiply(ot(r,d)).toBytes(p)}function w(d){const p=c(d);return{secretKey:p,publicKey:f(p)}}function y(d){if(typeof d=="bigint")return!1;if(d instanceof n)return!0;const{secretKey:p,publicKey:B,publicKeyUncompressed:q}=o;if(r.allowedLengths||p===B)return;const U=M("key",d).length;return U===B||U===q}function b(d,p,B=!0){if(y(d)===!0)throw new Error("first arg must be private key");if(y(p)===!1)throw new Error("second arg must be public key");const q=ot(r,d);return n.fromHex(p).multiply(q).toBytes(B)}return Object.freeze({getPublicKey:f,getSharedSecret:b,keygen:w,Point:n,utils:{isValidSecretKey:i,isValidPublicKey:s,randomSecretKey:c,isValidPrivateKey:i,randomPrivateKey:c,normPrivateKeyToScalar:d=>ot(r,d),precompute(d=8,p=n.BASE){return p.precompute(d,!1)}},lengths:o})}function tn(n,t,r={}){Pt(t),Vt(r,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});const e=r.randomBytes||Qt,o=r.hmac||((l,...u)=>te(t,l,W(...u))),{Fp:i,Fn:s}=n,{ORDER:c,BITS:f}=s,{keygen:w,getPublicKey:y,getSharedSecret:b,utils:a,lengths:d}=Je(n,r),p={prehash:!1,lowS:typeof r.lowS=="boolean"?r.lowS:!1,format:void 0,extraEntropy:!1},B="compact";function q(l){const u=c>>it;return l>u}function U(l,u){if(!s.isValidNot0(u))throw new Error(`invalid signature ${l}: out of range 1..Point.Fn.ORDER`);return u}function ft(l,u){Ot(u);const g=d.signature,m=u==="compact"?g:u==="recovered"?g+1:void 0;return J(l,m,`${u} signature`)}class Z{constructor(u,g,m){this.r=U("r",u),this.s=U("s",g),m!=null&&(this.recovery=m),Object.freeze(this)}static fromBytes(u,g=B){ft(u,g);let m;if(g==="der"){const{r:S,s:I}=z.toSig(J(u));return new Z(S,I)}g==="recovered"&&(m=u[0],g="compact",u=u.subarray(1));const v=s.BYTES,x=u.subarray(0,v),E=u.subarray(v,v*2);return new Z(s.fromBytes(x),s.fromBytes(E),m)}static fromHex(u,g){return this.fromBytes(mt(u),g)}addRecoveryBit(u){return new Z(this.r,this.s,u)}recoverPublicKey(u){const g=i.ORDER,{r:m,s:v,recovery:x}=this;if(x==null||![0,1,2,3].includes(x))throw new Error("recovery id invalid");if(c*me<g&&x>1)throw new Error("recovery id is ambiguous for h>1 curve");const S=x===2||x===3?m+c:m;if(!i.isValid(S))throw new Error("recovery id 2 or 3 invalid");const I=i.toBytes(S),L=n.fromBytes(W(pe((x&1)===0),I)),O=s.inv(S),_=X(M("msgHash",u)),R=s.create(-_*O),V=s.create(v*O),C=n.BASE.multiplyUnsafe(R).add(L.multiplyUnsafe(V));if(C.is0())throw new Error("point at infinify");return C.assertValidity(),C}hasHighS(){return q(this.s)}toBytes(u=B){if(Ot(u),u==="der")return mt(z.hexFromSig(this));const g=s.toBytes(this.r),m=s.toBytes(this.s);if(u==="recovered"){if(this.recovery==null)throw new Error("recovery bit must be present");return W(Uint8Array.of(this.recovery),g,m)}return W(g,m)}toHex(u){return st(this.toBytes(u))}assertValidity(){}static fromCompact(u){return Z.fromBytes(M("sig",u),"compact")}static fromDER(u){return Z.fromBytes(M("sig",u),"der")}normalizeS(){return this.hasHighS()?new Z(this.r,s.neg(this.s),this.recovery):this}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return st(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return st(this.toBytes("compact"))}}const P=r.bits2int||function(u){if(u.length>8192)throw new Error("input is too large");const g=xt(u),m=u.length*8-f;return m>0?g>>BigInt(m):g},X=r.bits2int_modN||function(u){return s.create(P(u))},nt=at(f);function lt(l){return He("num < 2^"+f,l,D,nt),s.toBytes(l)}function rt(l,u){return J(l,void 0,"message"),u?J(t(l),void 0,"prehashed message"):l}function A(l,u,g){if(["recovered","canonical"].some(R=>R in g))throw new Error("sign() legacy options not supported");const{lowS:m,prehash:v,extraEntropy:x}=Nt(g,p);l=rt(l,v);const E=X(l),S=ot(s,u),I=[lt(S),lt(E)];if(x!=null&&x!==!1){const R=x===!0?e(d.secretKey):x;I.push(M("extraEntropy",R))}const L=W(...I),O=E;function _(R){const V=P(R);if(!s.isValidNot0(V))return;const C=s.inv(V),H=n.BASE.multiply(V).toAffine(),T=s.create(H.x);if(T===D)return;const ht=s.create(C*s.create(O+T*S));if(ht===D)return;let Ct=(H.x===T?0:2)|Number(H.y&it),Mt=ht;return m&&q(ht)&&(Mt=s.neg(ht),Ct^=1),new Z(T,Mt,Ct)}return{seed:L,k2sig:_}}function dt(l,u,g={}){l=M("message",l);const{seed:m,k2sig:v}=A(l,u,g);return Ue(t.outputLen,s.BYTES,o)(m,v)}function Q(l){let u;const g=typeof l=="string"||Ut(l),m=!g&&l!==null&&typeof l=="object"&&typeof l.r=="bigint"&&typeof l.s=="bigint";if(!g&&!m)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");if(m)u=new Z(l.r,l.s);else if(g){try{u=Z.fromBytes(M("sig",l),"der")}catch(v){if(!(v instanceof z.Err))throw v}if(!u)try{u=Z.fromBytes(M("sig",l),"compact")}catch{return!1}}return u||!1}function N(l,u,g,m={}){const{lowS:v,prehash:x,format:E}=Nt(m,p);if(g=M("publicKey",g),u=rt(M("message",u),x),"strict"in m)throw new Error("options.strict was renamed to lowS");const S=E===void 0?Q(l):Z.fromBytes(M("sig",l),E);if(S===!1)return!1;try{const I=n.fromBytes(g);if(v&&S.hasHighS())return!1;const{r:L,s:O}=S,_=X(u),R=s.inv(O),V=s.create(_*R),C=s.create(L*R),H=n.BASE.multiplyUnsafe(V).add(I.multiplyUnsafe(C));return H.is0()?!1:s.create(H.x)===L}catch{return!1}}function h(l,u,g={}){const{prehash:m}=Nt(g,p);return u=rt(u,m),Z.fromBytes(l,"recovered").recoverPublicKey(u).toBytes()}return Object.freeze({keygen:w,getPublicKey:y,getSharedSecret:b,utils:a,lengths:d,Point:n,sign:dt,verify:N,recoverPublicKey:h,Signature:Z,hash:t})}function en(n){const t={a:n.a,b:n.b,p:n.Fp.ORDER,n:n.n,h:n.h,Gx:n.Gx,Gy:n.Gy},r=n.Fp;let e=n.allowedPrivateKeyLengths?Array.from(new Set(n.allowedPrivateKeyLengths.map(s=>Math.ceil(s/2)))):void 0;const o=ut(t.n,{BITS:n.nBitLength,allowedLengths:e,modFromBytes:n.wrapPrivateKey}),i={Fp:r,Fn:o,allowInfinityPoint:n.allowInfinityPoint,endo:n.endo,isTorsionFree:n.isTorsionFree,clearCofactor:n.clearCofactor,fromBytes:n.fromBytes,toBytes:n.toBytes};return{CURVE:t,curveOpts:i}}function nn(n){const{CURVE:t,curveOpts:r}=en(n),e={hmac:n.hmac,randomBytes:n.randomBytes,lowS:n.lowS,bits2int:n.bits2int,bits2int_modN:n.bits2int_modN};return{CURVE:t,curveOpts:r,hash:n.hash,ecdsaOpts:e}}function rn(n,t){const r=t.Point;return Object.assign({},t,{ProjectivePoint:r,CURVE:Object.assign({},n,he(r.Fn.ORDER,r.Fn.BITS))})}function on(n){const{CURVE:t,curveOpts:r,hash:e,ecdsaOpts:o}=nn(n),i=Qe(t,r),s=tn(i,e,o);return rn(n,s)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function sn(n,t){const r=e=>on({...n,hash:e});return{...r(t),create:r}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const kt={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},cn={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},Gt=BigInt(2);function fn(n){const t=kt.p,r=BigInt(3),e=BigInt(6),o=BigInt(11),i=BigInt(22),s=BigInt(23),c=BigInt(44),f=BigInt(88),w=n*n*n%t,y=w*w*n%t,b=j(y,r,t)*y%t,a=j(b,r,t)*y%t,d=j(a,Gt,t)*w%t,p=j(d,o,t)*d%t,B=j(p,i,t)*p%t,q=j(B,c,t)*B%t,U=j(q,f,t)*q%t,ft=j(U,c,t)*B%t,Z=j(ft,r,t)*y%t,P=j(Z,s,t)*p%t,X=j(P,e,t)*w%t,nt=j(X,Gt,t);if(!Rt.eql(Rt.sqr(nt),n))throw new Error("Cannot find square root");return nt}const Rt=ut(kt.p,{sqrt:fn}),un=sn({...kt,Fp:Rt,lowS:!0,endo:cn},Oe);export{un as secp256k1};
